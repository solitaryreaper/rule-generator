package com.walmartlabs.productgenome.rulegenerator.service;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import com.google.common.collect.Lists;
import com.walmartlabs.productgenome.rulegenerator.Constants;
import com.walmartlabs.productgenome.rulegenerator.model.Simmetrics;
import com.walmartlabs.productgenome.rulegenerator.model.data.Dataset;
import com.walmartlabs.productgenome.rulegenerator.model.data.DatasetNormalizerMeta;
import com.walmartlabs.productgenome.rulegenerator.model.data.Feature;
import com.walmartlabs.productgenome.rulegenerator.model.data.FeatureDataset;
import com.walmartlabs.productgenome.rulegenerator.model.data.FeatureVector;
import com.walmartlabs.productgenome.rulegenerator.model.data.ItemPair;
import com.walmartlabs.productgenome.rulegenerator.utils.SimilarityUtils;

/**
 * Generates new similarity features from the raw dataset.
 * 
 * @author excelsior
 *
 */
public class FeatureGenerationService {

	private static Logger LOG = Logger.getLogger(FeatureGenerationService.class.getName());
	
	/**
	 * Generates the new feature based dataset using the raw dataset.
	 * 
	 * The new features are generated by multiplexing raw attributes with
	 * relevant similarity metrics, to generate apt features.
	 * 
	 * @param rawDataset
	 * @return
	 */
	public static FeatureDataset generateFeatures(Dataset rawDataset, DatasetNormalizerMeta normalizerMeta)
	{
		String mapFileLoc = Constants.DATA_FILE_PATH_PREFIX + "_map_" + rawDataset.getName() + ".txt";
		File mapFile = new File(mapFileLoc);
		boolean isMapFileToBeGenerated = true;
		BufferedWriter bw = null;
		
		String name = null;
		List<Feature> features = null;
		List<FeatureVector> featureVectors = null;
		try {
			if(mapFile.exists()) {
				isMapFileToBeGenerated = false;
			}
			else {
				LOG.info("Generating new map file " + mapFileLoc);
				bw = new BufferedWriter(new FileWriter(mapFileLoc));
			}
			
			name = rawDataset.getName();
			Map<String, List<Simmetrics>> attrSimmetrics = 
					AttributeSimmetricsRecommender.getSimmetricRecommendations(rawDataset, normalizerMeta);

			features = getAllFeatures(attrSimmetrics);
			List<ItemPair> itemPairs = rawDataset.getItemPairs();
			featureVectors = Lists.newArrayList();		
			for(ItemPair itemPair : itemPairs) {
				FeatureVector fVector = getFeatureVector(itemPair, features);
				featureVectors.add(fVector);
				if(isMapFileToBeGenerated) {
					bw.write(itemPair.getItempPairIdentifier() + " ==> " + fVector.getFeatureString());
					bw.newLine();
				}
				
			}

			if(featureVectors.size() % 1000 == 0) {
				LOG.info("Total feature vectors : " + featureVectors.size());
			}
			
			if(isMapFileToBeGenerated) {
				bw.close();
				LOG.info("Map file " + mapFileLoc + " has been successfully generated ..");
			}
			
		}
		catch(Exception e) {
			LOG.severe("Error while generating feature dataset. Reason : " + e.getStackTrace());
		}
		
		LOG.info("Returning feature dataset ..");
		return new FeatureDataset(name, features, featureVectors);
	}
	
	/**
	 * Generates all features for the attributes in the current dataset using the
	 * recommended similarity metrics.
	 * @param attrSimmetrics
	 * @return	List of features
	 */
	private static List<Feature> getAllFeatures(Map<String, List<Simmetrics>> attrSimmetrics)
	{
		List<Feature> features = Lists.newArrayList();
		for(Map.Entry<String, List<Simmetrics>> entry : attrSimmetrics.entrySet()) {
			String attrName = entry.getKey().toLowerCase();
			for(Simmetrics metric : entry.getValue()) {
				features.add(new Feature(attrName, metric));
			}
		}
		
		return features;
	}
	
	/**
	 * Generates a feature vector, corresponding to the raw itempair.
	 * 
	 * Each feature is an application of a similarity metric on an attribute and the
	 * value represents the similarity score.
	 * @param itemPair
	 * @param features
	 * @return
	 */
	private static FeatureVector getFeatureVector(ItemPair itemPair, List<Feature> features)
	{
		List<Double> featureValues = Lists.newArrayList();
		for(Feature f: features) {
			String attrName = f.getAttrName();
			Simmetrics metric = f.getSimMetric();
			
			String itemAVal = itemPair.getItemAValByAttr(attrName);
			String itemBVal = itemPair.getItemBValByAttr(attrName);
			double score = SimilarityUtils.getSimilarity(metric, itemAVal, itemBVal);
			
			featureValues.add(score);
		}
		
		return new FeatureVector(featureValues, itemPair.getMatchStatus());
	}
	
}
